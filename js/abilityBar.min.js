

(function(){
 
 if(window.__abilityBarInjected){
 console.warn('[abilityBar] duplicate load prevented');
 return;
 }
 window.__abilityBarInjected = true;
 const SLOT_ORDER = [
 {slot:'basic', label:'LKM', key:'lmb'},
 {slot:'dash', label:'RKM', key:'rmb'},
 {slot:'q', label:'Q', key:'q'},
 {slot:'e', label:'E', key:'e'},
 {slot:'f', label:'F', key:'f'},
 {slot:'r', label:'R', key:'r'},
 {slot:'t', label:'T', key:'t'},
 {slot:'passive', label:'PASSIVE'},
 {slot:'reserve', label:'?'}
 ];

 
 
 

 function el(tag, cls){ const e=document.createElement(tag); if(cls) e.className=cls; return e; }
 function resolveAbilityForSlot(def){
 const ab = window.abilities; if(!ab) return null;
 
 if(def.key){ const b = ab.getBindingByKey(def.key); if(b) return ab.registry[b.ability]; }
 
 if(ab.registry[def.slot]) return ab.registry[def.slot];
 return null;
 }

 function build(){
 const host = document.getElementById('abilityBar'); if(!host) return;
 
 while(host.firstChild) host.removeChild(host.firstChild);
 
 const lockBtn = document.createElement('button');
 lockBtn.id='abilityBarLockBtn';
 lockBtn.textContent = window.abilities && window.abilities._locked ? 'ðŸ”’' : 'ðŸ”“';
 lockBtn.style.cssText='position:absolute;top:-14px;right:-14px;width:40px;height:40px;border-radius:50%;border:2px solid #e6c97a55;background:#1d1a14;color:#e6c97a;font-size:18px;cursor:pointer;box-shadow:0 2px 8px #000a;';
 lockBtn.addEventListener('click',()=>{ window.abilities._locked=!window.abilities._locked; lockBtn.textContent=window.abilities._locked?'ðŸ”’':'ðŸ”“'; document.getElementById('abilityBar')?.classList.toggle('locked', !!window.abilities._locked); });
 host.appendChild(lockBtn);
 SLOT_ORDER.forEach(def=>{
 const ability = resolveAbilityForSlot(def) || {name:'-', placeholder:true, showCondition:()=>true};
 try { if(ability && ability.showCondition && !ability.showCondition()) return; } catch(_e){}
 let variant = null; if(ability.variant) { try { variant = ability.variant(); } catch(_e){} }
 const lockedVisual = ability.placeholder || def.slot==='reserve' || def.slot==='passive';
 const slot = el('div','ab-slot '+def.slot+(lockedVisual?' locked':'') );
 slot.setAttribute('data-slot', def.slot);
 if(def.key) slot.setAttribute('data-key', def.key);
 
 const iconWrap = el('div','icon-wrap');
 const icon = el('div','icon');
 icon.textContent = (variant?.icon || ability.iconText || ability.icon || ability.name?.charAt(0) || (def.label||'?').charAt(0));
 
 let soulBadge = null;
 if(def.key==='r' && window.staffMeteor) {
 soulBadge = el('div','soul-badge');
 soulBadge.textContent = `${window.staffMeteor.souls||0}/${window.staffMeteor.soulsRequired||150}`;
 soulBadge.style.position = 'absolute';
 soulBadge.style.bottom = '-8px';
 soulBadge.style.right = '-8px';
 soulBadge.style.background = '#2a1e0a';
 soulBadge.style.color = '#ffe6a8';
 soulBadge.style.fontSize = '0.78em';
 soulBadge.style.fontWeight = 'bold';
 soulBadge.style.padding = '2px 7px';
 soulBadge.style.borderRadius = '8px';
 soulBadge.style.border = '1.5px solid #e6c97a';
 soulBadge.style.boxShadow = '0 1px 4px #000a';
 soulBadge.style.pointerEvents = 'none';
 icon.appendChild(soulBadge);
 slot.__soulBadge = soulBadge;
 }
 
 if(def.key==='r' && window.halberdUlt && window.weapons && window.player && window.weapons[window.player.weaponIndex]?.id==='halbard'){
 let badge = '';
 if(window.halberdUlt.state==='cooldown') badge = 'CD';
 else if(window.halberdUlt.phase===1) badge = '1';
 else if(window.halberdUlt.phase===2) badge = '2';
 else if(window.halberdUlt.phase===3) badge = '3';
 if(badge){
 const badgeEl = el('span','ult-badge');
 badgeEl.textContent = badge;
 badgeEl.style.position = 'absolute';
 badgeEl.style.right = '6px';
 badgeEl.style.top = '6px';
 badgeEl.style.background = '#ffb347';
 badgeEl.style.color = '#222';
 badgeEl.style.fontWeight = 'bold';
 badgeEl.style.borderRadius = '8px';
 badgeEl.style.padding = '2px 7px';
 badgeEl.style.fontSize = '1.1em';
 badgeEl.style.boxShadow = '0 1px 4px #0008';
 icon.appendChild(badgeEl);
 }
 }
 
 const overlay = el('div','cd-overlay'); 
 icon.appendChild(overlay);
 const num = el('div','cd-num'); 
 icon.appendChild(num);
 const stacks = el('div','ab-stacks'); 
 icon.appendChild(stacks);
 
 if(def.key){
 const keyLabel = el('div','key-label');
 keyLabel.textContent = def.label || def.key.toUpperCase();
 keyLabel.style.fontSize = '0.58em';
 keyLabel.style.color = '#d6d6d6';
 keyLabel.style.fontWeight = '600';
 keyLabel.style.textAlign = 'center';
 keyLabel.style.marginTop = '-2px';
 keyLabel.style.letterSpacing = '0.5px';
 iconWrap.appendChild(keyLabel);
 }
 
 if(def.slot==='basic'){
 const wBadge = el('div','w-lvl-badge');
 wBadge.textContent='';
 icon.appendChild(wBadge);
 slot.__weaponBadge = wBadge;
 }
 iconWrap.appendChild(icon);
 slot.appendChild(iconWrap);
 const name = el('div','name');
 const baseIdCap = ability.id ? (ability.id.charAt(0).toUpperCase()+ability.id.slice(1)) : '';
 name.textContent = (variant?.name || ability.uiName || ability.name || baseIdCap || def.label);
 slot.appendChild(name);
 if(variant && variant.available===false){ slot.classList.add('locked'); }
 if(lockedVisual && (ability.placeholder || def.slot==='reserve' || def.slot==='passive')){ const lock = el('div','lock'); lock.textContent='ðŸ”’'; slot.appendChild(lock); }
 slot.__meta = {def,ability,icon,overlay,num,stacks,root:slot};
 host.appendChild(slot);
 });
 enableDrag(host);
 }

 function update(){
 const host = document.getElementById('abilityBar'); if(!host || !host.children.length) return;
 [...host.children].forEach(slot=>{
 const meta = slot.__meta; if(!meta) return;
 const ability = resolveAbilityForSlot(meta.def) || meta.ability;
 if(ability && ability.showCondition && !ability.showCondition()){ 
 
 if(!window.__abNeedRebuild){ window.__abNeedRebuild = true; requestAnimationFrame(()=>{ if(window.__abNeedRebuild){ window.__abNeedRebuild=false; window._rebuildAbilityBar(); } }); }
 slot.style.display='none';
 return;
 } else {
 slot.style.display='';
 }
 
 if(ability && ability.variant){ let v=null; try { v=ability.variant(); } catch(_e){}
 if(v){
 const iconEl = slot.querySelector('.icon'); if(iconEl) iconEl.textContent = v.icon || iconEl.textContent;
 const nameEl = slot.querySelector('.name'); if(nameEl){
 const baseIdCap = ability.id ? (ability.id.charAt(0).toUpperCase()+ability.id.slice(1)) : '';
 nameEl.textContent = v.name || ability.uiName || ability.name || baseIdCap || nameEl.textContent;
 }
 if(v.available===false) slot.classList.add('locked'); else slot.classList.remove('locked');
 }
 }
 
 if(meta.def.slot==='basic' && slot.__weaponBadge){
 try {
 let w=null; if(window.player && window.weapons && Array.isArray(window.weapons) && window.player.weaponIndex!=null){ w = window.weapons[window.player.weaponIndex]; }
 const lvl = w && typeof w.lvl==='number' ? w.lvl : null;
 if(lvl!=null){ slot.__weaponBadge.textContent = 'lvl.'+lvl; slot.__weaponBadge.style.display='flex'; }
 else { slot.__weaponBadge.textContent=''; slot.__weaponBadge.style.display='none'; }
 if(lvl>=10) slot.__weaponBadge.classList.add('double'); else slot.__weaponBadge.classList.remove('double');
 } catch(_e){}
 }
 if(!ability) return;
 
 if(meta.def.key==='r' && window.staffMeteor && meta.icon && meta.root.__soulBadge){
 meta.root.__soulBadge.textContent = `${window.staffMeteor.souls||0}/${window.staffMeteor.soulsRequired||150}`;
 }
 let cd=0, timer=0; if(ability.cdGetter) cd=ability.cdGetter()||0; if(ability.timerGetter) timer=ability.timerGetter()||0;
 
 let remain = 0; if(cd>0) remain = Math.max(0, Math.min(1, timer/cd));
 if(meta.overlay){
 meta.overlay.style.setProperty('--cd-rem', remain);
 meta.overlay.style.opacity = remain>0 ? '1' : '0';
 }
 if(meta.num){
 if(remain>0){
 
 meta.num.textContent = timer>=1 ? Math.ceil(timer) : (timer>0 ? timer.toFixed(1) : '');
 } else {
 meta.num.textContent = '';
 }
 }
 if(meta.stacks){
 let stacksVal = 0;
 try { if(ability.stacksGetter) stacksVal = ability.stacksGetter()||0; } catch(_e){}
 if(stacksVal && stacksVal > 1){
 meta.stacks.textContent = stacksVal;
 meta.stacks.style.display = 'flex';
 if(stacksVal >= 10) meta.stacks.classList.add('double'); else meta.stacks.classList.remove('double');
 } else {
 meta.stacks.textContent = '';
 meta.stacks.style.display = 'none';
 }
 }
 if(remain>0){ slot.classList.add('dimmed'); slot.classList.remove('ready-pulse'); }
 else { if(slot.classList.contains('dimmed')){ slot.classList.add('ready-pulse'); setTimeout(()=>slot.classList.remove('ready-pulse'),900);} slot.classList.remove('dimmed'); }
 if(ability.activeGetter && ability.activeGetter()){ slot.style.filter='brightness(1.3) saturate(1.3)'; } else if(!slot.classList.contains('locked')) slot.style.filter='';
 });
 }

 function swapBinding(aKey,bKey){ const ab=window.abilities; if(!ab) return; const A=ab.getBindingByKey(aKey); const B=ab.getBindingByKey(bKey); if(!A && !B) return; if(A) A.key='__tmp'; if(B) B.key=aKey; if(A) A.key=bKey; ab.saveBindings(); }

 function enableDrag(host){
 let dragSrc=null;
 host.querySelectorAll('.ab-slot').forEach(slot=>{
 const key = slot.getAttribute('data-key');
 if(!key) return; 
 slot.setAttribute('draggable','true');
 slot.addEventListener('dragstart', e=>{ if(window.abilities._locked){ e.preventDefault(); return; } dragSrc=slot; slot.classList.add('dragging'); e.dataTransfer.effectAllowed='move'; e.dataTransfer.setData('text/plain', key); });
 slot.addEventListener('dragend', ()=>{ slot.classList.remove('dragging'); dragSrc=null; });
 slot.addEventListener('dragover', e=>{ if(window.abilities._locked) return; if(!dragSrc||dragSrc===slot) return; e.preventDefault(); slot.classList.add('drag-over'); });
 slot.addEventListener('dragleave', ()=>slot.classList.remove('drag-over'));
 slot.addEventListener('drop', e=>{ if(window.abilities._locked) return; e.preventDefault(); slot.classList.remove('drag-over'); if(!dragSrc||dragSrc===slot) return; const fromKey = dragSrc.getAttribute('data-key'); const toKey = slot.getAttribute('data-key'); if(fromKey && toKey){ swapBinding(fromKey,toKey); window._rebuildAbilityBar(); } });
 });
 }

 
 let tt; function ensureTooltip(){ if(tt) return tt; tt=document.createElement('div'); tt.id='abilityTooltip'; tt.style.cssText='position:fixed;z-index:50000;pointer-events:none;padding:10px 14px 10px 14px;background:rgba(18,14,10,0.92);border:1px solid #e6c97a55;border-radius:12px;box-shadow:0 4px 18px #000c,0 0 0 1px #000 inset;font-family:Montserrat,Orbitron,sans-serif;font-size:12px;line-height:1.35;max-width:260px;color:#e8e2d2;display:none;'; document.body.appendChild(tt); return tt; }
 function fmtCooldown(a){ if(!a) return ''; const cd = a.cdGetter?a.cdGetter():0; if(!cd) return ''; const t=a.timerGetter?a.timerGetter():0; const ready = t<=0; return ready?'<span style="color:#7ae66f;">Bereit</span>':'CD: '+t.toFixed(1)+'s / '+cd.toFixed(0)+'s'; }
 function showTooltip(slot, ability, ev){
 const box=ensureTooltip(); if(!ability) return;
 
 let variant=null; if(typeof ability.variant==='function'){ try { variant = ability.variant(); } catch(_e){} }
 const name = (variant && variant.name) || ability.uiName || ability.name || (ability.id?ability.id.charAt(0).toUpperCase()+ability.id.slice(1):'');
 const desc = (variant && variant.desc) || ability.desc || '(Keine Beschreibung)';
 const cdLine = fmtCooldown(ability);
 box.innerHTML = '<div style="font-weight:700;font-size:13px;margin-bottom:4px;color:#ffe6a8;text-shadow:0 0 6px #000;">'+name+'</div>'+
 '<div style="opacity:.9;margin-bottom:6px;white-space:pre-line;">'+desc+'</div>'+
 '<div style="font-size:11px;color:#ccb98a;">'+cdLine+'</div>';
 box.style.display='block';
 positionTooltip(ev);
 }
 function hideTooltip(){ if(tt) tt.style.display='none'; }
 function positionTooltip(ev){ if(!tt||tt.style.display==='none') return; const pad=14; let x=ev.clientX+16, y=ev.clientY+18; const w=tt.offsetWidth, h=tt.offsetHeight; if(x+w > window.innerWidth-pad) x = window.innerWidth - w - pad; if(y+h > window.innerHeight-pad) y = window.innerHeight - h - pad; tt.style.left=x+'px'; tt.style.top=y+'px'; }

 document.addEventListener('mousemove', e=>{ if(tt && tt.dataset.follow==='1') positionTooltip(e); });

 function wireTooltips(){
 const host=document.getElementById('abilityBar'); if(!host) return; host.querySelectorAll('.ab-slot').forEach(slot=>{
 slot.addEventListener('mouseenter', ev=>{ if(window.abilities?._locked===undefined?false:false){} const def=slot.__meta?.def; if(!def) return; const ab=resolveAbilityForSlot(def); if(!ab) return; if(slot.classList.contains('dragging')) return; showTooltip(slot, ab, ev); tt.dataset.follow='1'; });
 slot.addEventListener('mousemove', ev=>{ if(tt && tt.style.display==='block') positionTooltip(ev); });
 slot.addEventListener('mouseleave', ()=>{ hideTooltip(); });
 slot.addEventListener('dragstart', ()=>{ hideTooltip(); });
 });
 }

 
 
 
 const _prevRebuild = (typeof window._rebuildAbilityBar === 'function') ? window._rebuildAbilityBar : null;
 let _rebuildRunning = false;
 let _rebuildQueued = false;
 function doRebuild(){
 if(_rebuildRunning){ _rebuildQueued = true; return; }
 _rebuildRunning = true;
 try {
 if(_prevRebuild){ _prevRebuild(); } else { build(); }
 wireTooltips();
 } finally {
 _rebuildRunning = false;
 if(_rebuildQueued){ _rebuildQueued=false; doRebuild(); }
 }
 }
 window._rebuildAbilityBar = doRebuild;

 
 const style = document.createElement('style');
 style.textContent = `#abilityBar.locked .ab-slot{cursor:default;} #abilityBar .ab-slot.dragging{opacity:.4;filter:grayscale(.8);} #abilityBar .ab-slot.drag-over{outline:2px dashed #ffe600;}`;
 document.head.appendChild(style);

 
 function ready(){ if(!document.getElementById('abilityBar')) return false; build(); return true; }
 let tries=0; (function wait(){ if(ready()) return; if(tries++<40) setTimeout(wait,120); })();
 
 (function loop(){ update(); requestAnimationFrame(loop); })();

 
 let lastChar='__init__';
 let lastWeapon='__init__';
 (function watchCharWeapon(){
 let char=(window.selectedCharacter||'').toLowerCase();
 if(!char && typeof character==='string') char=character.toLowerCase();
 let wId='';
 try {
 if(window.player && window.weapons && Array.isArray(window.weapons) && window.player.weaponIndex!=null){
 const w = window.weapons[window.player.weaponIndex]; if(w) wId = w.id || ''; }
 } catch(_e){}
 if(char!==lastChar || wId!==lastWeapon){
 lastChar=char; lastWeapon=wId;
 
 if(!window.__abSchedule){
 window.__abSchedule = true;
 requestAnimationFrame(()=>{ window.__abSchedule=false; if(typeof window._rebuildAbilityBar==='function') window._rebuildAbilityBar(); });
 }
 }
 requestAnimationFrame(watchCharWeapon);
 })();

 
 if(!window.__abConsoleHelper){
 window.__abConsoleHelper = true;
 window.rebuildAbilityBarRaw = build; 
 }
})();
